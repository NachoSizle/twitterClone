{"version":3,"sources":["meteor://ðŸ’»app/packages/modules/server.js","meteor://ðŸ’»app/packages/modules/buffer.js","meteor://ðŸ’»app/packages/modules/install-packages.js","meteor://ðŸ’»app/packages/modules/process.js","meteor://ðŸ’»app/node_modules/meteor/modules/node_modules/reify/lib/runtime.js","meteor://ðŸ’»app/node_modules/meteor/modules/node_modules/reify/lib/entry.js","meteor://ðŸ’»app/node_modules/meteor/modules/node_modules/reify/lib/utils.js","meteor://ðŸ’»app/node_modules/bcrypt/package.json","meteor://ðŸ’»app/node_modules/bcrypt/bcrypt.js","meteor://ðŸ’»app/node_modules/bindings/package.json","meteor://ðŸ’»app/node_modules/bindings/bindings.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7CA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5KA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/modules.js","sourcesContent":["require(\"./install-packages.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\nrequire(\"reify/lib/runtime\").enable(module.constructor);\n","try {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n","function install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (mainModule) {\n    meteorDir[name + \".js\"] = [mainModule, function (require, e, module) {\n      module.exports = require(mainModule);\n    }];\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"npm-mongo\");\ninstall(\"modules-runtime\");\ninstall(\"modules\", \"meteor/modules/server.js\");\ninstall(\"es5-shim\", \"meteor/es5-shim/server.js\");\ninstall(\"promise\", \"meteor/promise/server.js\");\ninstall(\"ecmascript-runtime\", \"meteor/ecmascript-runtime/runtime.js\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"minimongo\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"ddp-client\");\ninstall(\"rate-limit\");\ninstall(\"ddp-rate-limiter\");\ninstall(\"logging\");\ninstall(\"routepolicy\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"html-tools\");\ninstall(\"blaze-tools\");\ninstall(\"spacebars-compiler\");\ninstall(\"observe-sequence\");\ninstall(\"jquery\");\ninstall(\"reactive-var\");\ninstall(\"blaze\");\ninstall(\"spacebars\");\ninstall(\"ui\");\ninstall(\"boilerplate-generator\");\ninstall(\"webapp-hashing\");\ninstall(\"webapp\");\ninstall(\"callback-hook\");\ninstall(\"ddp-server\");\ninstall(\"ddp\");\ninstall(\"allow-deny\");\ninstall(\"binary-heap\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"shell-server\", \"meteor/shell-server/main.js\");\ninstall(\"twbs:bootstrap\");\ninstall(\"session\");\ninstall(\"accounts-ui\");\ninstall(\"npm-bcrypt\", \"meteor/npm-bcrypt/wrapper.js\");\ninstall(\"accounts-base\", \"meteor/accounts-base/server_main.js\");\ninstall(\"sha\");\ninstall(\"srp\");\ninstall(\"email\");\ninstall(\"accounts-password\");\ninstall(\"reywood:publish-composite\");\ninstall(\"templating-compiler\");\ninstall(\"templating-runtime\");\ninstall(\"templating\");\ninstall(\"iron:core\");\ninstall(\"iron:dynamic-template\");\ninstall(\"iron:layout\");\ninstall(\"iron:url\");\ninstall(\"iron:middleware-stack\");\ninstall(\"iron:location\");\ninstall(\"reactive-dict\");\ninstall(\"iron:controller\");\ninstall(\"iron:router\");\ninstall(\"fourseven:scss\");\ninstall(\"sacha:spin\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"autoupdate\");\ninstall(\"reload\");\ninstall(\"service-configuration\");\n","try {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n","var Entry = require(\"./entry.js\").Entry;\nvar utils = require(\"./utils.js\");\n\nexports.enable = function (Module) {\n  var Mp = Module.prototype;\n\n  if (typeof Mp.import === \"function\" &&\n      typeof Mp.export === \"function\") {\n    // If the Mp.{import,export} methods have already been\n    // defined, abandon reification immediately.\n    return Module;\n  }\n\n  // Platform-specific code should implement this method however\n  // appropriate. Module.prototype.resolve(id) should return an absolute\n  // version of the given module identifier, like require.resolve.\n  Mp.resolve = Mp.resolve || function resolve(id) {\n    throw new Error(\"Module.prototype.resolve not implemented\");\n  };\n\n  // Platform-specific code should find a way to call this method whenever\n  // the module system is about to return module.exports from require. This\n  // might happen more than once per module, in case of dependency cycles,\n  // so we want Module.prototype.runModuleSetters to run each time.\n  Mp.runModuleSetters = function runModuleSetters(valueToPassThrough) {\n    var entry = Entry.get(this.id);\n    if (entry) {\n      entry.runModuleSetters(this);\n    }\n\n    // Assignments to exported local variables get wrapped with calls to\n    // module.runModuleSetters, so module.runModuleSetters returns the\n    // valueToPassThrough parameter to allow the value of the original\n    // expression to pass through. For example,\n    //\n    //   export var a = 1;\n    //   console.log(a += 3);\n    //\n    // becomes\n    //\n    //   module.export(\"a\", () => a);\n    //   var a = 1;\n    //   console.log(module.runModuleSetters(a += 3));\n    //\n    // This ensures module.runModuleSetters runs immediately after the\n    // assignment, and does not interfere with the larger computation.\n    return valueToPassThrough;\n  };\n\n  function setESModule(module) {\n    var exports = module.exports;\n    if (exports && typeof exports === \"object\") {\n      exports.__esModule = true;\n    }\n  }\n\n  Mp.import = function (id, setters) {\n    var module = this;\n    setESModule(module);\n\n    var absoluteId = module.resolve(id);\n\n    if (setters && typeof setters === \"object\") {\n      var entry = Entry.getOrCreate(absoluteId);\n      entry.addSetters(module, setters);\n    }\n\n    var countBefore = entry && entry.runCount;\n    var exports = typeof module.require === \"function\"\n      ? module.require(absoluteId)\n      : require(absoluteId);\n\n    if (entry && entry.runCount === countBefore) {\n      // If require(absoluteId) didn't run any setters for this entry,\n      // perhaps because it's not the first time this module has been\n      // required, run the setters now using an object that passes as the\n      // real module object.\n      entry.runModuleSetters({\n        id: absoluteId,\n        exports: exports,\n        getExportByName: Mp.getExportByName\n      });\n    }\n  };\n\n  // Register getter functions for local variables in the scope of an\n  // export statement. The keys of the getters object are exported names,\n  // and the values are functions that return local values.\n  Mp.export = function (getters) {\n    var module = this;\n    setESModule(module);\n\n    if (utils.isPlainObject(getters)) {\n      Entry.getOrCreate(module.id).addGetters(getters);\n    }\n\n    if (module.loaded) {\n      // If the module has already been evaluated, then we need to trigger\n      // another round of entry.runModuleSetters calls, which begins by\n      // calling entry.runModuleGetters(module).\n      module.runModuleSetters();\n    }\n  };\n\n  // This method can be overridden by client code to implement custom export\n  // naming logic. The current implementation works well with Babel's\n  // __esModule convention.\n  Mp.getExportByName = function (name) {\n    var exports = this.exports;\n\n    if (name === \"*\") {\n      return exports;\n    }\n\n    if (name === \"default\" &&\n        ! (exports &&\n           typeof exports === \"object\" &&\n           exports.__esModule &&\n           \"default\" in exports)) {\n      return exports;\n    }\n\n    return exports && exports[name];\n  };\n\n  return Module;\n};\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar entryMap = Object.create(null);\nvar utils = require(\"./utils.js\");\n\nfunction Entry(id) {\n  // Same as module.id for this module.\n  this.id = id;\n  // The number of times this.runModuleSetters has been called.\n  this.runCount = 0;\n  // Setters for assigning to local variables in parent modules.\n  this.setters = Object.create(null);\n  // Getters for local variables exported from this module.\n  this.getters = Object.create(null);\n}\n\nvar Ep = Entry.prototype;\n\nEntry.get = function (id) {\n  return entryMap[id] || null;\n};\n\nEntry.getOrCreate = function (id) {\n  return entryMap[id] = entryMap[id] || new Entry(id);\n};\n\nEp.addSetters = function (parent, setters) {\n  var entry = this;\n\n  Object.keys(setters).forEach(function (name) {\n    var setter = setters[name];\n    if (typeof setter === \"function\" &&\n        // Ignore any requests for the exports.__esModule property.\"\n        name !== \"__esModule\") {\n      setter.parent = parent;\n      (entry.setters[name] =\n       entry.setters[name] || []\n      ).push(setter);\n    }\n  });\n};\n\nEp.addGetters = function (getters) {\n  var entry = this;\n  Object.keys(getters).forEach(function (name) {\n    var getter = getters[name];\n    if (typeof getter === \"function\" &&\n        // Ignore any requests for the exports.__esModule property.\"\n        name !== \"__esModule\") {\n      // Should this throw if hasOwn.call(this.getters, name)?\n      entry.getters[name] = getter;\n    }\n  });\n};\n\nfunction runModuleSetters(module) {\n  var entry = entryMap[module.id];\n  if (entry) {\n    entry.runModuleSetters(module);\n  }\n}\n\nfunction runModuleGetters(module) {\n  var entry = entryMap[module.id];\n  return entry ? entry.runModuleGetters(module) : 0;\n}\n\nEp.runModuleGetters = function (module) {\n  var entry = this;\n  var changeCount = 0;\n\n  Object.keys(entry.getters).forEach(function (name) {\n    if (entry.runGetter(module, name)) {\n      ++changeCount;\n    }\n  });\n\n  return changeCount;\n};\n\n// Returns true iff the getter updated module.exports with a new value.\nEp.runGetter = function (module, name) {\n  if (! hasOwn.call(this.getters, name)) {\n    return false;\n  }\n\n  var getter = this.getters[name];\n  try {\n    var value = getter.call(module);\n  } catch (e) {}\n  var exports = module.exports;\n\n  if (! hasOwn.call(exports, name) ||\n      exports[name] !== value) {\n    // We update module.exports[name] with the current value so that\n    // CommonJS require calls remain consistent with module.import.\n    exports[name] = value;\n    return true;\n  }\n\n  return false;\n};\n\n// Called whenever module.exports might have changed, to trigger any\n// setters associated with the newly exported values.\nEp.runModuleSetters = function (module) {\n  var entry = this;\n  var names = Object.keys(entry.setters);\n\n  // Make sure module.exports is up to date before we call\n  // module.getExportByName(name).\n  entry.runModuleGetters(module);\n\n  // Invoke the given callback once for every (setter, value, name) triple\n  // that needs to be called. Note that forEachSetter does not call any\n  // setters itself, only the given callback.\n  function forEachSetter(callback, context) {\n    names.forEach(function (name) {\n      entry.setters[name].forEach(function (setter) {\n        var value = module.getExportByName(name);\n        if (name === \"*\") {\n          Object.keys(value).forEach(function (name) {\n            call(setter, value[name], name);\n          });\n        } else {\n          call(setter, value, name);\n        }\n      });\n    });\n\n    function call(setter, value, name) {\n      if (name === \"__esModule\") {\n        // Ignore setters asking for module.exports.__esModule.\n        return;\n      }\n\n      setter.last = setter.last || Object.create(null);\n\n      if (! hasOwn.call(setter.last, name) ||\n          setter.last[name] !== value) {\n        // Only invoke the callback if we have not called this setter\n        // (with a value of this name) before, or the current value is\n        // different from the last value we passed to this setter.\n        return callback.apply(context, arguments);\n      }\n    }\n  }\n\n  // Every three elements of this list form a (setter, value, name) triple\n  // that needs to be invoked.\n  var settersToCall = [];\n\n  // Lazily-initialized objects mapping parent module identifiers to\n  // relevant parent module objects and snapshots of their exports.\n  var relevantParents;\n  var parentSnapshots;\n\n  // Take snapshots of setter.parent.exports for any setters that we are\n  // planning to call, so that we can later determine if calling the\n  // setters modified any of those exports objects.\n  forEachSetter(function (setter, value, name) {\n    var parent = setter.parent;\n    parentSnapshots = parentSnapshots || Object.create(null);\n    if (! hasOwn.call(parentSnapshots, parent.id)) {\n      relevantParents = relevantParents || Object.create(null);\n      relevantParents[parent.id] = parent;\n      if (utils.isPlainObject(parent.exports)) {\n        // If parent.exports is an object, make a shallow clone of it so\n        // that we can see if it changes as a result of calling setters.\n        parentSnapshots[parent.id] = utils.assign({}, parent.exports);\n      } else {\n        // If parent.exports is not an object, the \"snapshot\" is just the\n        // value of parent.exports.\n        parentSnapshots[parent.id] = parent.exports;\n      }\n    }\n\n    // Push three elements at a time to avoid creating wrapper arrays for\n    // each (setter, value, name) triple. Note the i += 3 below.\n    settersToCall.push(setter, value, name);\n  });\n\n  // Now call all the setters that we decided we need to call.\n  for (var i = 0; i < settersToCall.length; i += 3) {\n    var setter = settersToCall[i];\n    var value = settersToCall[i + 1];\n    var name = settersToCall[i + 2];\n    setter.call(module, setter.last[name] = value, name);\n  }\n\n  ++entry.runCount;\n\n  if (! relevantParents) {\n    // If we never called takeSnapshot, then we can avoid checking\n    // relevantParents and parentSnapshots below.\n    return;\n  }\n\n  // If any of the setters updated the module.exports of a parent module,\n  // or updated local variables that are exported by that parent module,\n  // then we must re-run any setters registered by that parent module.\n  Object.keys(relevantParents).forEach(function (id) {\n    var parent = relevantParents[id];\n\n    if (runModuleGetters(parent) > 0) {\n      return runModuleSetters(parent);\n    }\n\n    var exports = parent.exports;\n    var snapshot = parentSnapshots[parent.id];\n    if (utils.shallowObjEqual(exports, snapshot)) {\n      // If parent.exports have not changed since we took the snapshot,\n      // then we do not need to run the parent's setters.\n      return;\n    }\n\n    runModuleSetters(parent);\n  });\n};\n\nexports.Entry = Entry;\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar objToStr = Object.prototype.toString;\nvar objStr = objToStr.call({});\n\nfunction isPlainObject(value) {\n  return objToStr.call(value) === objStr;\n}\nexports.isPlainObject = isPlainObject;\n\nexports.assign = Object.assign || function (obj) {\n  var argc = arguments.length;\n  for (var i = 1; i < argc; ++i) {\n    var arg = arguments[i];\n    if (arg && typeof arg === \"object\") {\n      var keys = Object.keys(arg);\n      for (var k = 0; k < keys.length; ++k) {\n        var key = keys[k];\n        obj[key] = arg[key];\n      }\n    }\n  }\n  return obj;\n};\n\nexports.shallowObjEqual = function(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (! isPlainObject(a) ||\n      ! isPlainObject(b)) {\n    return false;\n  }\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  return aKeys.every(function (key) {\n    return hasOwn.call(b, key) &&\n      a[key] === b[key];\n  });\n};\n","exports.name = \"bcrypt\";\nexports.version = \"0.8.7\";\nexports.main = \"./bcrypt\";\n","'use strict';\r\n\r\nvar bindings = require('bindings')('bcrypt_lib');\r\nvar crypto = require('crypto');\r\n\r\n/// generate a salt (sync)\r\n/// @param {Number} [rounds] number of rounds (default 10)\r\n/// @return {String} salt\r\nmodule.exports.genSaltSync = function(rounds) {\r\n    // default 10 rounds\r\n    if (!rounds) {\r\n        rounds = 10;\r\n    } else if (typeof rounds !== 'number') {\r\n        throw new Error('rounds must be a number');\r\n    }\r\n\r\n    return bindings.gen_salt_sync(rounds, crypto.randomBytes(16));\r\n};\r\n\r\n/// generate a salt\r\n/// @param {Number} [rounds] number of rounds (default 10)\r\n/// @param {Function} cb callback(err, salt)\r\nmodule.exports.genSalt = function(rounds, ignore, cb) {\r\n    // if callback is first argument, then use defaults for others\r\n    if (typeof arguments[0] === 'function') {\r\n        // have to set callback first otherwise arguments are overriden\r\n        cb = arguments[0];\r\n        rounds = 10;\r\n    // callback is second argument\r\n    } else if (typeof arguments[1] === 'function') {\r\n        // have to set callback first otherwise arguments are overriden\r\n        cb = arguments[1];\r\n    }\r\n\r\n    // default 10 rounds\r\n    if (!rounds) {\r\n        rounds = 10;\r\n    } else if (typeof rounds !== 'number') {\r\n        // callback error asynchronously\r\n        return process.nextTick(function() {\r\n            cb(new Error('rounds must be a number'));\r\n        });\r\n    }\r\n\r\n    if (!cb) {\r\n        return;\r\n    }\r\n\r\n    crypto.randomBytes(16, function(error, randomBytes) {\r\n        if (error) {\r\n            cb(error);\r\n            return;\r\n        }\r\n\r\n        bindings.gen_salt(rounds, randomBytes, cb);\r\n    });\r\n};\r\n\r\n/// hash data using a salt\r\n/// @param {String} data the data to encrypt\r\n/// @param {String} salt the salt to use when hashing\r\n/// @return {String} hash\r\nmodule.exports.hashSync = function(data, salt) {\r\n    if (data == null || salt == null) {\r\n        throw new Error('data and salt arguments required');\r\n    }\r\n\r\n    if (typeof data !== 'string' || (typeof salt !== 'string' && typeof salt !== 'number')) {\r\n        throw new Error('data must be a string and salt must either be a salt string or a number of rounds');\r\n    }\r\n\r\n    if (typeof salt === 'number') {\r\n        salt = module.exports.genSaltSync(salt);\r\n    }\r\n\r\n    return bindings.encrypt_sync(data, salt);\r\n};\r\n\r\n/// hash data using a salt\r\n/// @param {String} data the data to encrypt\r\n/// @param {String} salt the salt to use when hashing\r\n/// @param {Function} cb callback(err, hash)\r\nmodule.exports.hash = function(data, salt, cb) {\r\n    if (typeof data === 'function') {\r\n        return process.nextTick(function() {\r\n            data(new Error('data must be a string and salt must either be a salt string or a number of rounds'));\r\n        });\r\n    }\r\n\r\n    if (typeof salt === 'function') {\r\n        return process.nextTick(function() {\r\n            salt(new Error('data must be a string and salt must either be a salt string or a number of rounds'));\r\n        });\r\n    }\r\n\r\n    if (data == null || salt == null) {\r\n        return process.nextTick(function() {\r\n            cb(new Error('data and salt arguments required'));\r\n        });\r\n    }\r\n\r\n    if (typeof data !== 'string' || (typeof salt !== 'string' && typeof salt !== 'number')) {\r\n        return process.nextTick(function() {\r\n            cb(new Error('data must be a string and salt must either be a salt string or a number of rounds'));\r\n        });\r\n    }\r\n\r\n    if (!cb || typeof cb !== 'function') {\r\n        return;\r\n    }\r\n\r\n    if (typeof salt === 'number') {\r\n        return module.exports.genSalt(salt, function(err, salt) {\r\n            return bindings.encrypt(data, salt, cb);\r\n        });\r\n    }\r\n\r\n    return bindings.encrypt(data, salt, cb);\r\n};\r\n\r\n/// compare raw data to hash\r\n/// @param {String} data the data to hash and compare\r\n/// @param {String} hash expected hash\r\n/// @return {bool} true if hashed data matches hash\r\nmodule.exports.compareSync = function(data, hash) {\r\n    if (data == null || hash == null) {\r\n        throw new Error('data and hash arguments required');\r\n    }\r\n\r\n    if (typeof data !== 'string' || typeof hash !== 'string') {\r\n        throw new Error('data and hash must be strings');\r\n    }\r\n\r\n    return bindings.compare_sync(data, hash);\r\n};\r\n\r\n/// compare raw data to hash\r\n/// @param {String} data the data to hash and compare\r\n/// @param {String} hash expected hash\r\n/// @param {Function} cb callback(err, matched) - matched is true if hashed data matches hash\r\nmodule.exports.compare = function(data, hash, cb) {\r\n    if (data == null || hash == null) {\r\n        return process.nextTick(function() {\r\n            cb(new Error('data and hash arguments required'));\r\n        });\r\n    }\r\n\r\n    if (typeof data !== 'string' || typeof hash !== 'string') {\r\n        return process.nextTick(function() {\r\n            cb(new Error('data and hash must be strings'));\r\n        });\r\n    }\r\n\r\n    if (!cb || typeof cb !== 'function') {\r\n        return;\r\n    }\r\n\r\n    return bindings.compare(data, hash, cb);\r\n};\r\n\r\n/// @param {String} hash extract rounds from this hash\r\n/// @return {Number} the number of rounds used to encrypt a given hash\r\nmodule.exports.getRounds = function(hash) {\r\n    if (hash == null) {\r\n        throw new Error('hash argument required');\r\n    }\r\n\r\n    if (typeof hash !== 'string') {\r\n        throw new Error('hash must be a string');\r\n    }\r\n\r\n    return bindings.get_rounds(hash);\r\n};\r\n","exports.name = \"bindings\";\nexports.version = \"1.2.1\";\nexports.main = \"./bindings.js\";\n","\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar fs = require('fs')\r\n  , path = require('path')\r\n  , join = path.join\r\n  , dirname = path.dirname\r\n  , exists = fs.existsSync || path.existsSync\r\n  , defaults = {\r\n        arrow: process.env.NODE_BINDINGS_ARROW || ' â†’ '\r\n      , compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled'\r\n      , platform: process.platform\r\n      , arch: process.arch\r\n      , version: process.versions.node\r\n      , bindings: 'bindings.node'\r\n      , try: [\r\n          // node-gyp's linked version in the \"build\" dir\r\n          [ 'module_root', 'build', 'bindings' ]\r\n          // node-waf and gyp_addon (a.k.a node-gyp)\r\n        , [ 'module_root', 'build', 'Debug', 'bindings' ]\r\n        , [ 'module_root', 'build', 'Release', 'bindings' ]\r\n          // Debug files, for development (legacy behavior, remove for node v0.9)\r\n        , [ 'module_root', 'out', 'Debug', 'bindings' ]\r\n        , [ 'module_root', 'Debug', 'bindings' ]\r\n          // Release files, but manually compiled (legacy behavior, remove for node v0.9)\r\n        , [ 'module_root', 'out', 'Release', 'bindings' ]\r\n        , [ 'module_root', 'Release', 'bindings' ]\r\n          // Legacy from node-waf, node <= 0.4.x\r\n        , [ 'module_root', 'build', 'default', 'bindings' ]\r\n          // Production \"Release\" buildtype binary (meh...)\r\n        , [ 'module_root', 'compiled', 'version', 'platform', 'arch', 'bindings' ]\r\n        ]\r\n    }\r\n\r\n/**\r\n * The main `bindings()` function loads the compiled bindings for a given module.\r\n * It uses V8's Error API to determine the parent filename that this function is\r\n * being invoked from, which is then used to find the root directory.\r\n */\r\n\r\nfunction bindings (opts) {\r\n\r\n  // Argument surgery\r\n  if (typeof opts == 'string') {\r\n    opts = { bindings: opts }\r\n  } else if (!opts) {\r\n    opts = {}\r\n  }\r\n  opts.__proto__ = defaults\r\n\r\n  // Get the module root\r\n  if (!opts.module_root) {\r\n    opts.module_root = exports.getRoot(exports.getFileName())\r\n  }\r\n\r\n  // Ensure the given bindings name ends with .node\r\n  if (path.extname(opts.bindings) != '.node') {\r\n    opts.bindings += '.node'\r\n  }\r\n\r\n  var tries = []\r\n    , i = 0\r\n    , l = opts.try.length\r\n    , n\r\n    , b\r\n    , err\r\n\r\n  for (; i<l; i++) {\r\n    n = join.apply(null, opts.try[i].map(function (p) {\r\n      return opts[p] || p\r\n    }))\r\n    tries.push(n)\r\n    try {\r\n      b = opts.path ? require.resolve(n) : require(n)\r\n      if (!opts.path) {\r\n        b.path = n\r\n      }\r\n      return b\r\n    } catch (e) {\r\n      if (!/not find/i.test(e.message)) {\r\n        throw e\r\n      }\r\n    }\r\n  }\r\n\r\n  err = new Error('Could not locate the bindings file. Tried:\\n'\r\n    + tries.map(function (a) { return opts.arrow + a }).join('\\n'))\r\n  err.tries = tries\r\n  throw err\r\n}\r\nmodule.exports = exports = bindings\r\n\r\n\r\n/**\r\n * Gets the filename of the JavaScript file that invokes this function.\r\n * Used to help find the root directory of a module.\r\n * Optionally accepts an filename argument to skip when searching for the invoking filename\r\n */\r\n\r\nexports.getFileName = function getFileName (calling_file) {\r\n  var origPST = Error.prepareStackTrace\r\n    , origSTL = Error.stackTraceLimit\r\n    , dummy = {}\r\n    , fileName\r\n\r\n  Error.stackTraceLimit = 10\r\n\r\n  Error.prepareStackTrace = function (e, st) {\r\n    for (var i=0, l=st.length; i<l; i++) {\r\n      fileName = st[i].getFileName()\r\n      if (fileName !== __filename) {\r\n        if (calling_file) {\r\n            if (fileName !== calling_file) {\r\n              return\r\n            }\r\n        } else {\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // run the 'prepareStackTrace' function above\r\n  Error.captureStackTrace(dummy)\r\n  dummy.stack\r\n\r\n  // cleanup\r\n  Error.prepareStackTrace = origPST\r\n  Error.stackTraceLimit = origSTL\r\n\r\n  return fileName\r\n}\r\n\r\n/**\r\n * Gets the root directory of a module, given an arbitrary filename\r\n * somewhere in the module tree. The \"root directory\" is the directory\r\n * containing the `package.json` file.\r\n *\r\n *   In:  /home/nate/node-native-module/lib/index.js\r\n *   Out: /home/nate/node-native-module\r\n */\r\n\r\nexports.getRoot = function getRoot (file) {\r\n  var dir = dirname(file)\r\n    , prev\r\n  while (true) {\r\n    if (dir === '.') {\r\n      // Avoids an infinite loop in rare cases, like the REPL\r\n      dir = process.cwd()\r\n    }\r\n    if (exists(join(dir, 'package.json')) || exists(join(dir, 'node_modules'))) {\r\n      // Found the 'package.json' file or 'node_modules' dir; we're done\r\n      return dir\r\n    }\r\n    if (prev === dir) {\r\n      // Got to the top\r\n      throw new Error('Could not find module root given file: \"' + file\r\n                    + '\". Do you have a `package.json` file? ')\r\n    }\r\n    // Try the parent dir next\r\n    prev = dir\r\n    dir = join(dir, '..')\r\n  }\r\n}\r\n"]}